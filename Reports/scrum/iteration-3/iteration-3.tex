\chapter{Scrum iteration 3: stabilizing libtorrent and experiments}
\label{iteration3}
	In this chapter we describe our third sprint, starting in week 4.5 (19$^{th}$ of May) and ending in week 4.6 (30$^{th}$ of May).

	\section{Goals}
		This sprint, we had the following goals:
	
		\begin{enumerate}
			\item Write unit tests for our Python code and application tests for our application (must: applications must be tested thoroughly to ensure all possible settings are working correctly). 
			\item Send our tests to the SIG (must: this is required by the bachelor thesis).
			\item Investigate the segmentation fault and check for alternative solutions (should: as much as we love to see libtorrent becoming stable, we are not sure if we will succeed with this goal).
			\item Update to the new Tribler code (should: while it is not a critical feature, it is good practice to keep the code up to date).
			\item Measure CPU usage and download rates of our application (should: while it is not needed in order to run the application, it is good to have some performance measurements).
		\end{enumerate}
		
	\section{Application tests}
		In order to verify the application is working correctly we have implemented automated testing. Using the default unit test framework provided by python and the Kivy recorder we were able to setup basic user interface tests. These tests run the application, perform a series of user actions such as clicking buttons and finally assert the state of the application. The tests currently run successfully on Jenkins, which means that future additions to the code will automatically be tested.
		
	\section{RUTracker libtorrent}
		Since we would like to have a stable libtorrent library that downloads a torrent without segmentation faults, we decided to try out the libtorrent that Jaap van Touw used in his Bachelor thesis. This is an older version of libtorrent but has proven to be successful in his project. Jaap provided us with a link to a GitHub page that contains instructions on how to build libtorrent from source (https://github.com/pepibumur/Torrent-Movies). This libtorrent version is used in an Android application called RUTracker, an Android application that allows users to download and upload torrent files in the background. We thought it would be a good idea to try out this libtorrent because it seemed to be quite stable.
		
		Instead of using a custom toolchain like we did to compile libtorrent-rasterbar, we used the toolchain that ships with the NDK. The first step was to build some Boost libraries libtorrent depends on (Boost.filesystem, Boost.system and Boost.thread). We used the Boost for Android project (https://github.com/MysticTreeGames/Boost-for-Android) to build Boost 1.49. After that, we compiled libtorrent according to the instruction given by the Torrent Movies project. We linked against the Boost libraries we just compiled and we got a shared object file we can use in our Android application.
		
		\subsection{Python bindings}
			After writing a small example to test if our compiled libtorrent library is stable, we came to the conclusion that it does not crash. Since this libtorrent version looks promising, we delved into the Python bindings we need to communicate between Python and a native C library. Importing this library without Python bindings, results in an error that an initializer function could not been found.
		
			For the Python bindings, it is convenient to use the Boost.python library. This library contains several macros and methods to easily define our Python calls. The macro BOOST\_PYTHON\_MODULE, declared in boost/python.hpp, initializes our Python library and makes it ready for an import in Python. However, when running a minimal Python script that only imports libtorrent, a segmentation fault is thrown. This means that we are unable to use this version of libtorrent in Python. We are not sure what is the cause of this error. If the initialization and import of the library would work correctly, we could write our own bindings for the libtorrent functions and methods we need in Tribler.
			
	\section{Libtorrent RC2 progress}
		While we were working on the Russian libtorrent version, we also kept working on the Release Candidate (RC) 2 version of libtorrent we originally tried. The first step we took, is to compile libtorrent with asserts on. We did this to gain a better understanding in why the segmentation fault occurred. An assert had indeed triggered: in the destructor of the Torrent class, the m\_abort variable should be true but it was false. This could mean that the Torrent object is released too soon.
		
		We decided to post the issue to the official libtorrent bug tracker where we got in contact with a libtorrent developer named Arvid. He helped us debugging the error and gave us the advice to compile with the BOOST\_SP\_USE\_PTHREADS flag. When we tried to compile with this flag but we still got the segmentation fault. We looked closer on what exactly this flag does. It turns out that this flag is responsible for the shared pointers: according to Arvid, with this define the shared pointers are using mutex operations instead of atomic operations. He had some bad experience with atomic operations on embedded devices. To force the use of the right mechanism with the shared pointers, we modified the source code of Boost. We edited the file sp\_counted\_base.hpp which is part of the smart\_ptr submodule of Boost. Instead of including boost/smart\_ptr/detail/sp\_counted\_base\_spin.hpp on line 30 and 78, one should include boost/smart\_ptr/detail/sp\_counted\_base\_pt.hpp. After compiling Boost and libtorrent with this modifications, the native application seems to run stable.
		
		It turned out that we should have compiled libtorrent with the same flag. The first time we tried to compile, we only compiled boost with the suggested flag. When we tried to compile libtorrent with the flag, it turned out that the internal system is now using the pthread shared pointers. We are glad to have a stable version of libtorrent now.
				
	\section{Updating the Tribler package}
		This sprint had also the goal to update the Tribler package we are using. The Tribler repository was updated with a huge change, the package Twisted was updated to version 14.0.0, certain callbacks were removed and a Twisted reactor was introduced. This meant we had to update our Twisted version as well and update our package.
		When we began updating, we discovered that the default recipe in the Python for Android framework required adaptation, simply upgrading the version number did not work. After inspecting the recipe we asked for advice on the Kivy repository, and luckily a member had updated his Twisted to version 13.1.0. He showed his adaptations and fortunately these were also compatible with the latest Twisted release.
		
		The next step was updating the Tribler package. Previously, we downloaded the package and adapted it. Because it was not forked on GitHub we could not automatically update it. We decided to fix this issue immediately and thus created a fork of the main Tribler branch. From this fresh fork we added some path changes to make the new Tribler code compatible with our application. This is necessary because several files that get opened by Tribler assume the working directory is the Tribler root. This does not work when executing on more exotic environments such as Android, where the working directory might be different.
		
		Since our package is now a fork, future updates are more easy to merge into our package using the GitHub merge functionality.
			
	\section{Relaying and downloading over multiple hops/multiple circuits}
		In our last sprint, we had some issues with downloading and relaying over multiple hops/multiple circuits. Downloading the 50 MB test file was working correctly over one circuit with one hop, however, adjusting the values of the minimum amount of circuits required for the downloading and the length of the hop would not work.
		
		To debug this issue, we got in contact with Rutger and Chris, the original authors of the anontunnels code. They suggested us to place loggers when receiving messages from other nodes and look closely to the incoming messages while disabling the encryption. We logged the messages but we could not find anything that could cause the application to reject circuits. The same code, when executed on a laptop, can successful download over multiple circuits with multiple hops.
		
		At this time, we were quite some commits behind the devel branch of Tribler. After updating and merging our package with the newest code, we tried again and the downloads were starting. We immediately tried to download the anonymous test file over four circuits and three hops and it worked fine. Also other lengths and other amounts of circuits were working correctly. During the tests (see chapter \ref{cpt:experiments}) we came to the conclusion that three hop encryption is too heavy for a smartphone.
		
		In order to verify the stability of relaying and downloading, even with encryption disabled, we decided to write a test application that can keep running overnight. We can start some anontunnel instances on our own computers and let the test application download the torrent. After the download is finished, the application restarts and the process starts over. The output is redirected to a log file so we can see issues or problems that occurred during the download.
			
	\section{Conclusion}
		This sprint was the most successful one so far. We managed to stabilize libtorrent, updated our Tribler package and made preparations to apply future updates more easy. Furthermore we managed identify the problem with our download and relaying issue with multiple hops and multiple circuits. The stable environment and the option to download via multiple hops and circuits allowed us to gather data and generate graphs. These graphs will be used in our final report to explain certain characteristics we observe and will also be analyzed with respect to streaming content.
		
		The additional unit tests contributed to the stability and robustness of our application. These new tests along with the previous ones from iteration 2 are sent to the SIG for evaluation. The feedback of the evaluation will be processed in the next scrum iteration.
		
		Looking back we can conclude that this sprint was very successful. A lot of work has been done and most of our big problems are solved. In the next iteration we will focus on finalizing the report, create a solid demo application and tweak our code where necessary.
