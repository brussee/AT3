\section{Iteration 2}
\label{iteration2}
	In this section we describe our second sprint, starting in week 4.5 (19$^{th}$ of May) and ending in week 4.6 (30$^{th}$ of May).

	\subsection{Goals}
		This sprint, we had the following goals:
	
		\begin{enumerate}
			\item Get libtorrent from sprint 1 working.
			\item Get the anon tunnels running,relaying and downloading.
			\item Merge our work with the other group to create a first prototype of the complete application.
		\end{enumerate}
	
	\subsection{Jenkins}
		In this sprint we decided to make use of the continuous integration system called Jenkins. Jenkins automatically runs your tests when a build has been changed or a pull request comes in/has changed. 
		Even though this was not specified in our plan of action initially, we think this is a good addition to improve and maintain the (code) quality of our application.
		
		Jenkins allows for an own environment to run tests in, which is perfect for our setup. Currently Jenkins executes the following steps:
		
		\begin{enumerate}
			\item Jenkins cleans the environment when a build starts, so nothing is cached.
			\item It then clones our repository and the Python for Android framework from GitHub.
			\item Optionally, if the build is from a pull request, merge the pull request with the master branch.
			\item Jenkins then starts up an Android emulator where the application can be installed and tested on with application tests.
			\item Once the emulator is started up, the unit and application tests are run. If one of the tests fail, Jenkins will mark the build as failed. Else the build succeeds.
			\item Finally once the tests are done the Tribler bot comments the result on the pull request if that's what was running, else it reports the result of the project in our IRC channel.
		\end{enumerate} 
		
		Because this is done for every change and pull request, we can closely monitor if changes have unexpected side effects. If they do, we can address them immediately to prevent the problem from spreading or growing more complex if the number of dependencies increase.
		
	\subsection{Libtorrent}
		We have continued working on libtorrent in this sprint and have made major progress in getting it to work on Android devices. Using steeve's help from last sprint we were able to get a basic version of libtorrent to compile and link for android. In this sprint we wanted to test the compiled version and create python bindings.
		
		\subsubsection{Testing libtorrent with a simple application}
			We have built a simple test application with JNI C++ bindings in order to test whether libtorrent actually works. This application does the minimal work required for downloading a torrent:
			\begin{itemize}
			\item It sets up a session
			\item It starts listening
			\item It opens a torrent file
			\item It keeps looping while requesting status updates to keep track of the progress
			\end{itemize}
			This very simple torrent client turned out to work well on a Galaxy S2 device. We were able to download the official Ubuntu 14.04 distribution without problems. By manually checking the md5 checksum of the file we were able to verify that it was downloaded successfully.
		
		\subsubsection{Compiling python bindings}
			Normally, to compile python bindings, one has to simply add the \texttt{--enable-python-binding} to the \texttt{configure} call and that's all. However, doing that in our case causes the configure process to fail. It starts complaining that the gcc-arm toolchain can not link with \texttt{-lpthread} and \texttt{-lutil}. We were kind of stumped by this since these are standard C++ libraries.
			
			After much research we have finally found out what causes this. Essentially the configure process calls a bunch of \texttt{m4} files which try to find out your python compilation settings automatically. This is done by running a Python interpreter and printing specific values obtained from distutils. However, it turns out that the python process that gets run is the system Python installation (from Ubuntu). This obviously does not match the same settings of Python for Android's interpreter. To solve this we had to set some environment variables to point to Python for Android's interpreter:
			
			\begin{itemize}
				\item \texttt{PYTHON = /path/to/python-for-android/build/python/Python2.7.2/hostpython}
				\item \texttt{PYTHON\_CPP\_FLAGS="-I/path/to/python-for-android/python/Python2.7.2/Include"}
			\end{itemize}
			
			After setting this the configure and compilation process runs fine and is able to create a libtorrent.so file with python bindings. The compiled library works on a Galaxy S2 device. We created a simple python application that downloaded the Ubuntu distribution. This again went without problems.
			
		\subsubsection{Segmentation faults on other devices}
			Running libtorrent, either the native JNI/C++ version or the Python bindings version results in segmentation faults on some devices but not others. For example, the Sony Xperia Z throws segmentation faults frequently, whereas this never occurs on the Samsung Galaxy S2. 
			
			After a lot of debugging it is still not exactly clear what triggers these segmentation faults. They seem to be very random.
			
	
	\subsection{Conclusion}
		Hier komen onze conclusies over deze sprint (wat ging er goed/fout, wat willen we anders doen, wat gaan we volgende sprint doen etc.)
